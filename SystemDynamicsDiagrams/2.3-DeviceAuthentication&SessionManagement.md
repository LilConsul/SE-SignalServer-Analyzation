```mermaid
sequenceDiagram
    participant C as ğŸ“± Client Device
    participant LB as âš–ï¸ Load Balancer
    participant API as ğŸŒ HTTP API Gateway
    participant AF as ğŸ” AuthenticationFilter
    participant AM as ğŸ‘¥ AccountsManager
    participant DM as ğŸ“± DeviceManager
    participant SM as ğŸ« SessionManager
    participant CACHE as ğŸ”´ Redis Cache
    participant DB as ğŸ“Š DynamoDB

    rect rgba(173, 216, 230, 0.15)
        Note over C,DB: ğŸ” PHASE 1: Device Authentication Setup
        
        C->>+LB: ğŸ“¤ PUT /v1/accounts/attributes<br/>ğŸ” Authorization: Basic {number}:{password}
        Note right of C: ğŸ“‹ First-time device setup:<br/>ğŸ“± Device capabilities<br/>ğŸ”” Push token registration<br/>âš™ï¸ Client configuration
        
        LB->>+API: ğŸ”„ Route authenticated request
        API->>+AF: ğŸ” authenticateRequest(authHeader, endpoint)
        
        rect rgba(255, 255, 224, 0.3)
            Note over AF: Authentication Validation
            AF->>AF: ğŸ“‹ Parse Basic Auth header<br/>ğŸ“± Extract {phoneNumber, authToken}<br/>ğŸ” Validate format & encoding
        end
        
        AF->>+AM: ğŸ” getByE164AndAuthToken(phoneNumber, authToken)
        
        par Cache Lookup
            AM->>+CACHE: ğŸ” GET account:{phoneNumber}:auth<br/>â° TTL check (3600s)
            CACHE-->>-AM: ğŸ“‹ Cached account or cache miss
        and Database Fallback
            alt ğŸ’¾ Cache Miss
                AM->>+DB: ğŸ“Š Query accounts table<br/>ğŸ”‘ GSI: phoneNumberIndex<br/>ğŸ” Filter: authToken match
                DB-->>-AM: ğŸ“‹ Account record with devices[]
                AM->>+CACHE: ğŸ’¾ SET account cache<br/>â° TTL: 1 hour
                CACHE-->>-AM: âœ… Account cached
            end
        end
        
        AM-->>-AF: ğŸ‘¤ AuthenticatedAccount{uuid, deviceId, capabilities}
        AF-->>-API: âœ… Authentication successful<br/>ğŸ‘¤ Principal: {account, device}
    end

    rect rgba(240, 255, 240, 0.15)
        Note over C,DB: ğŸ“± PHASE 2: Device Registration & Session Creation
        
        API->>+DM: ğŸ“± updateDeviceAttributes(account, deviceId, attributes)
        
        rect rgba(245, 255, 250, 0.3)
            Note over DM: Device State Management
            DM->>DM: ğŸ”„ Update device capabilities<br/>ğŸ“± {GCM, APNS, WebSocket support}<br/>ğŸ”” Update push tokens<br/>â° Set lastSeen timestamp
        end
        
        DM->>+SM: ğŸ« createOrUpdateSession(account, device, clientInfo)
        
        rect rgba(248, 248, 255, 0.3)
            Note over SM: Session Lifecycle
            SM->>SM: ğŸ†” Generate session ID<br/>â° Set expiration (30 days)<br/>ğŸ” Create session token<br/>ğŸ“Š Initialize session metrics
        end
        
        par Session Storage
            SM->>+CACHE: ğŸ’¾ SET session:{sessionId}<br/>ğŸ“‹ {accountId, deviceId, created, expires}<br/>â° TTL: 30 days
            CACHE-->>-SM: âœ… Session cached
        and Device Update
            DM->>+DB: ğŸ”„ UpdateItem accounts table<br/>ğŸ”‘ Key: {ACI}<br/>ğŸ“‹ Update: devices[deviceId].{lastSeen, pushTokens}
            DB-->>-DM: âœ… Device attributes updated
        end
        
        SM-->>-DM: ğŸ« SessionInfo{sessionId, token, expires}
        DM-->>-API: ğŸ“± DeviceUpdateResponse{capabilities, sessionInfo}
    end

    rect rgba(255, 248, 220, 0.15)
        Note over C,DB: ğŸ”„ PHASE 3: Ongoing Authentication & Session Validation
        
        loop ğŸ”„ Subsequent API Requests
            C->>+LB: ğŸ“¤ Any API Request<br/>ğŸ” Authorization: Bearer {sessionToken}
            LB->>+API: ğŸ”„ Route request
            API->>+AF: ğŸ” validateSession(bearerToken)
            
            AF->>+CACHE: ğŸ” GET session:{tokenHash}<br/>â° Check expiration
            
            alt âœ… Valid Session
                CACHE-->>AF: ğŸ“‹ Session data{accountId, deviceId, scope[]}
                AF->>+AM: ğŸ” getAccount(accountId)
                AM->>+CACHE: ğŸ” Account lookup (cached)
                CACHE-->>-AM: ğŸ‘¤ Account details
                AM-->>-AF: âœ… Valid account
                AF-->>API: âœ… Authenticated request<br/>ğŸ‘¤ Principal: {account, device, session}
                
                par Session Refresh
                    AF->>+CACHE: ğŸ”„ EXPIRE session:{tokenHash}<br/>â° Extend TTL by usage
                    CACHE-->>-AF: âœ… TTL extended
                and Activity Tracking
                    AF->>+CACHE: ğŸ“Š INCR activity:{accountId}:{date}<br/>â° TTL: 24 hours
                    CACHE-->>-AF: ğŸ“ˆ Activity recorded
                end
                
            else âŒ Invalid/Expired Session
                CACHE-->>AF: ğŸš« Session not found or expired
                AF-->>API: âš ï¸ HTTP 401 Unauthorized<br/>ğŸ” WWW-Authenticate: Bearer
                API-->>LB: ğŸš« Authentication required
                LB-->>C: ğŸ” Re-authentication needed
            end
            
            API->>API: ğŸ¯ Process authenticated request
            API-->>-LB: ğŸ“¤ API response
            LB-->>-C: âœ… Request completed
        end
    end

    rect rgba(255, 235, 235, 0.15)
        Note over C,DB: ğŸ”„ PHASE 4: Session Cleanup & Security
        
        Note over SM,CACHE: ğŸ§¹ Background Session Management
        
        loop â° Every 6 hours
            SM->>+CACHE: ğŸ” SCAN expired sessions<br/>ğŸ—‘ï¸ TTL < current time
            CACHE-->>-SM: ğŸ“‹ List of expired sessions
            
            SM->>+DB: ğŸ§¹ Cleanup session references<br/>ğŸ—‘ï¸ Remove from device records
            DB-->>-SM: âœ… Cleanup complete
            
            SM->>+CACHE: ğŸ“Š Collect session metrics<br/>ğŸ“ˆ Active sessions, device types
            CACHE-->>-SM: ğŸ“Š Metrics data
        end
        
        alt ğŸš¨ Security Event Detection
            SM->>SM: ğŸ” Detect suspicious activity<br/>ğŸ“± Multiple devices, geo-anomalies
            SM->>+AM: ğŸš¨ triggerSecurityReview(accountId, event)
            AM->>AM: ğŸ” Revoke suspicious sessions<br/>ğŸ“§ Send security notification
            AM-->>-SM: âœ… Security review complete
        end
    end
```