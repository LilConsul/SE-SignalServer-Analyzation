# ğŸ” Signal Server Registration & Authentication Flow

## ğŸ“± 1. Phone Number Verification

```mermaid
sequenceDiagram
    %% Enhanced participant styling with icons and clear roles
    participant C as ğŸ“± Client App
    participant LB as âš–ï¸ Load Balancer
    participant API as ğŸŒ HTTP API Gateway
    participant VC as âœ… VerificationController
    participant RSC as ğŸ¯ RegistrationServiceClient
    participant CACHE as ğŸ”´ Redis Cache
    participant SMS as ğŸ“ SMS/Voice Provider

    %% Phase 1: Initial Session Creation
    rect rgba(173, 216, 230, 0.15)
        Note over C,CACHE: ğŸš€ PHASE 1: Verification Session Setup
        
        C->>+LB: ğŸ“¤ POST /v1/verification/session<br/>ğŸ“‹ {phoneNumber, pushToken, captcha}
        Note right of C: Rate Limited:<br/>5 requests/hour per IP
        
        LB->>+API: ğŸ”„ Route to verification endpoint
        API->>+VC: ğŸ¯ createSession(CreateVerificationSessionRequest)
        
        rect rgba(255, 255, 224, 0.3)
            Note over VC: Input Validation
            VC->>VC: ğŸ“‹ Validate phone number format<br/>ğŸŒ Check country code allowlist<br/>ğŸš« Validate against blocklist
        end
        
        VC->>+RSC: ğŸ”— createRegistrationSession(phoneNumber, sourceHost)
        Note right of RSC: ğŸ”Œ gRPC call to Registration Service<br/>â±ï¸ Timeout: 15s<br/>ğŸ”„ Retry: 3 attempts
        RSC-->>-VC: âœ… RegistrationServiceSession<br/>ğŸ†” {sessionId, expiration: 10min}
        
        VC->>+CACHE: ğŸ’¾ Store session metadata<br/>ğŸ”‘ Key: session:{sessionId}<br/>â° TTL: 10 minutes
        CACHE-->>-VC: âœ… Session cached successfully
        
        VC-->>-API: ğŸ“¤ VerificationSessionResponse<br/>ğŸ†” {sessionId, requestedInfo[CAPTCHA]}
        API-->>-LB: âœ… HTTP 200 OK
        LB-->>-C: ğŸ‰ Session created - Ready for verification
    end

    %% Phase 2: Code Request and Delivery
    rect rgba(255, 228, 225, 0.15)
        Note over C,CACHE: ğŸ“ PHASE 2: Verification Code Delivery
        
        C->>+LB: ğŸ“¤ PATCH /v1/verification/session/{sessionId}<br/>ğŸ“‹ {transport: "sms", captchaResponse}
        Note right of C: Transport options:<br/>ğŸ“± SMS, â˜ï¸ Voice call
        
        LB->>+API: ğŸ”„ Route code request
        API->>+VC: ğŸ”„ updateSession(sessionId, transport, captcha)
        
        rect rgba(255, 240, 245, 0.3)
            Note over VC,CACHE: Session Validation
            VC->>+CACHE: ğŸ” Validate session exists & not expired
            CACHE-->>-VC: âœ… Valid session found
            VC->>VC: ğŸ” Verify CAPTCHA response<br/>ğŸš¦ Check rate limits (1 req/min per number)
        end
        
        VC->>+RSC: ğŸ“ sendVerificationCode(sessionId, SMS, clientType)
        RSC->>+SMS: ğŸ“¤ Forward to Twilio/Voice provider
        Note right of SMS: ğŸ“± SMS: "Your Signal code: 123456"<br/>â±ï¸ Valid for: 10 minutes<br/>ğŸ”„ Max attempts: 3
        SMS-->>-RSC: âœ… Message queued for delivery
        RSC-->>-VC: ğŸ“‹ RegistrationServiceSession(verified: false, codesSent: 1)
        
        VC->>+CACHE: ğŸ”„ Update session state<br/>ğŸ“Š {codesSent++, lastCodeSent: timestamp}
        CACHE-->>-VC: âœ… Session state updated
        
        VC-->>-API: ğŸ“¤ VerificationSessionResponse<br/>ğŸ“± {transport: "sms", nextCodeIn: 60s}
        API-->>-LB: âœ… HTTP 200 OK
        LB-->>-C: ğŸ“ Verification code sent via SMS
    end

    %% Phase 3: Code Verification
    rect rgba(240, 255, 240, 0.15)
        Note over C,CACHE: âœ… PHASE 3: Code Verification
        
        C->>+LB: ğŸ“¤ PUT /v1/verification/session/{sessionId}/code<br/>ğŸ“‹ {verificationCode: "123456"}
        
        LB->>+API: ğŸ”„ Route verification
        API->>+VC: âœ… verifyCode(sessionId, code)
        
        VC->>+CACHE: ğŸ” Retrieve session data
        CACHE-->>-VC: ğŸ“‹ Session metadata
        
        VC->>+RSC: ğŸ” checkVerificationCode(sessionId, code)
        Note right of RSC: ğŸ” Validate against sent code<br/>â±ï¸ Check expiration<br/>ğŸ”¢ Max 3 attempts
        
        alt âœ… Code Valid
            RSC-->>VC: âœ… RegistrationServiceSession(verified: true)
            VC->>+CACHE: ğŸ”„ Mark session as verified<br/>ğŸ† {verified: true, verifiedAt: timestamp}
            CACHE-->>-VC: âœ… Updated
            VC-->>API: ğŸ‰ VerificationComplete{sessionId, phoneNumber}
        else âŒ Code Invalid
            RSC-->>VC: âŒ InvalidCodeException(attemptsRemaining: 2)
            VC-->>API: âš ï¸ HTTP 422 Invalid Code
        else ğŸš« Too Many Attempts
            RSC-->>VC: ğŸš« RateLimitedException
            VC->>CACHE: ğŸ”’ Blacklist session for 5 minutes
            VC-->>API: ğŸš« HTTP 429 Too Many Requests
        end
        
        API-->>-LB: Response based on verification result
        LB-->>-C: Verification result
    end
```

## ğŸ‘¤ 2. Account Registration with Enhanced Security

```mermaid
sequenceDiagram
    participant C as ğŸ“± Client App
    participant LB as âš–ï¸ Load Balancer
    participant API as ğŸŒ HTTP API Gateway
    participant RC as ğŸ“ RegistrationController
    participant PVTM as ğŸ« PhoneVerificationTokenManager
    participant RLVM as ğŸ”’ RegistrationLockVerificationManager
    participant AM as ğŸ‘¥ AccountsManager
    participant KM as ğŸ”‘ KeysManager
    participant DB as ğŸ“Š DynamoDB
    participant CACHE as ğŸ”´ Redis Cache

    rect rgba(135, 206, 250, 0.15)
        Note over C,CACHE: ğŸš€ PHASE 1: Registration Request & Validation
        
        C->>+LB: ğŸ“¤ POST /v1/registration<br/>ğŸ“‹ {sessionId, accountAttributes, identityKeys}
        Note right of C: ğŸ“¦ Payload includes:<br/>ğŸ†” Verified sessionId<br/>ğŸ‘¤ Account attributes<br/>ğŸ” Identity keypairs (ACI/PNI)<br/>ğŸ“± Device capabilities
        
        LB->>+API: ğŸ”„ Route registration request
        API->>+RC: ğŸ“ register(RegistrationRequest)
        
        rect rgba(255, 255, 224, 0.3)
            Note over RC,PVTM: Phone Verification Check
            RC->>+PVTM: ğŸ« verifyPhoneVerificationToken(sessionId, phoneNumber)
            PVTM->>PVTM: ğŸ” Validate session exists<br/>âœ… Check verification status<br/>â±ï¸ Verify not expired (16s timeout)
            PVTM-->>-RC: âœ… Phone number verified successfully
        end
    end

    rect rgba(255, 228, 225, 0.15)
        Note over C,CACHE: ğŸ” PHASE 2: Existing Account Check & Registration Lock
        
        RC->>+AM: ğŸ” getByE164(phoneNumber)
        AM->>+DB: ğŸ“Š Query accounts table<br/>ğŸ”‘ GSI: phoneNumberIndex<br/>ğŸ“± Key: {phoneNumber}
        DB-->>-AM: ğŸ“‹ Optional<Account> result
        AM-->>-RC: ğŸ‘¤ existingAccount (if found)
        
        alt ğŸ”’ Existing Account with Registration Lock
            rect rgba(255, 240, 245, 0.3)
                Note over RC,RLVM: Registration Lock Security Flow
                RC->>+RLVM: ğŸ” verifyRegistrationLock(account, clientPin, userAgent)
                RLVM->>RLVM: ğŸš¦ Check rate limit: 1 attempt/5min per account<br/>ğŸ“Š Get attempt history from cache
                
                alt ğŸ”¢ PIN Provided
                    RLVM->>RLVM: ğŸ” Validate PIN against stored Argon2 hash<br/>ğŸ§‚ Use account-specific salt
                    
                    alt âŒ PIN Invalid
                        RLVM->>RLVM: ğŸ“Š Record failed attempt<br/>ğŸ“… Calculate idle days since last seen<br/>ğŸ”„ Increment attempt counter
                        RLVM->>+CACHE: ğŸ’¾ Store failed attempt<br/>ğŸ”‘ Key: reglock:{uuid}<br/>â° TTL: 5 minutes
                        CACHE-->>-RLVM: âœ… Attempt recorded
                        RLVM-->>RC: ğŸš« RateLimitExceededException(423)<br/>â±ï¸ {timeRemaining, attemptsLeft}
                        RC-->>API: âš ï¸ HTTP 423 Registration Locked
                        API-->>LB: ğŸ“‹ {timeRemaining, registrationLock: true, idleDays}
                        LB-->>C: ğŸ”’ Account locked - Correct PIN required
                    else âœ… PIN Valid
                        RLVM->>+CACHE: ğŸ—‘ï¸ Clear failed attempts<br/>ğŸ”‘ Key: reglock:{uuid}
                        CACHE-->>-RLVM: âœ… Attempts cleared
                        RLVM-->>RC: âœ… Registration lock verified
                    end
                else ğŸ“… 7-Day Bypass Available
                    RLVM->>RLVM: ğŸ“Š Check if account idle > 7 days<br/>ğŸ“… Compare lastSeen vs current time
                    RLVM-->>RC: âœ… Bypass allowed - account dormant
                end
                RLVM-->>-RC: ğŸ”“ Registration lock verification complete
            end
        end
    end

    rect rgba(240, 255, 240, 0.15)
        Note over C,CACHE: ğŸ‘¤ PHASE 3: Account Creation & Key Management
        
        RC->>+AM: ğŸ‘¤ create(phoneNumber, attributes, badges[], aciKey, pniKey)
        
        rect rgba(245, 255, 250, 0.3)
            Note over AM: Account Identity Generation
            AM->>AM: ğŸ†” Generate ACI UUID (Account Identity)<br/>ğŸ“± Generate PNI UUID (Phone Number Identity)<br/>ğŸ” Create Device(id: 1, authToken, salt)<br/>ğŸ“Š Initialize account metrics
        end
        
        par Account Storage
            AM->>+DB: ğŸ’¾ PutItem accounts table<br/>ğŸ”‘ Partition Key: ACI<br/>ğŸ“‹ Attributes: {phoneNumber, pni, devices[], createdAt}
            Note right of DB: ğŸ“Š Account record with:<br/>ğŸ†” ACI (primary identifier)<br/>ğŸ“± PNI (phone-linked ID)<br/>ğŸ“‹ Device list with capabilities<br/>ğŸ† Badge assignments
            DB-->>-AM: âœ… Account stored successfully
        and Key Storage
            AM->>+KM: ğŸ”‘ storeIdentityKeys(aci, pni, identityKeys)
            KM->>+DB: ğŸ’¾ PutItem keys table<br/>ğŸ”‘ Keys: ACI+PNI identity keypairs<br/>ğŸ“ Metadata: {algorithm, created, deviceId}
            DB-->>-KM: âœ… Identity keys stored
            KM-->>-AM: âœ… Keys management complete
        and Cache Update
            AM->>+CACHE: ğŸ’¾ SET account:{ACI}<br/>ğŸ“‹ Full account object<br/>â° TTL: 3600s (1 hour)
            CACHE-->>-AM: âœ… Account cached for fast access
        end
        
        AM-->>-RC: ğŸ‰ Account created successfully<br/>ğŸ“‹ {uuid: ACI, pni: PNI, deviceId: 1}
    end

    rect rgba(255, 248, 220, 0.15)
        Note over C,CACHE: ğŸ‰ PHASE 4: Registration Completion
        
        RC-->>-API: ğŸ“¤ RegistrationResponse<br/>ğŸ“‹ {uuid, pni, deviceId, storageCapable: true}
        Note right of API: ğŸ“¦ Response includes:<br/>ğŸ†” Account UUID (ACI)<br/>ğŸ“± Phone Number Identity (PNI)<br/>ğŸ“± Primary device ID<br/>ğŸ’¾ Storage capability flag
        
        API-->>-LB: âœ… HTTP 201 Created<br/>ğŸ† Registration successful
        LB-->>-C: ğŸ‰ Account registration complete!<br/>ğŸ” Ready for secure messaging
    end
```

## ğŸ” 3. Device Authentication & Session Management

```mermaid
sequenceDiagram
    participant C as ğŸ“± Client Device
    participant LB as âš–ï¸ Load Balancer
    participant API as ğŸŒ HTTP API Gateway
    participant AF as ğŸ” AuthenticationFilter
    participant AM as ğŸ‘¥ AccountsManager
    participant DM as ğŸ“± DeviceManager
    participant SM as ğŸ« SessionManager
    participant CACHE as ğŸ”´ Redis Cache
    participant DB as ğŸ“Š DynamoDB

    rect rgba(173, 216, 230, 0.15)
        Note over C,DB: ğŸ” PHASE 1: Device Authentication Setup
        
        C->>+LB: ğŸ“¤ PUT /v1/accounts/attributes<br/>ğŸ” Authorization: Basic {number}:{password}
        Note right of C: ğŸ“‹ First-time device setup:<br/>ğŸ“± Device capabilities<br/>ğŸ”” Push token registration<br/>âš™ï¸ Client configuration
        
        LB->>+API: ğŸ”„ Route authenticated request
        API->>+AF: ğŸ” authenticateRequest(authHeader, endpoint)
        
        rect rgba(255, 255, 224, 0.3)
            Note over AF: Authentication Validation
            AF->>AF: ğŸ“‹ Parse Basic Auth header<br/>ğŸ“± Extract {phoneNumber, authToken}<br/>ğŸ” Validate format & encoding
        end
        
        AF->>+AM: ğŸ” getByE164AndAuthToken(phoneNumber, authToken)
        
        par Cache Lookup
            AM->>+CACHE: ğŸ” GET account:{phoneNumber}:auth<br/>â° TTL check (3600s)
            CACHE-->>-AM: ğŸ“‹ Cached account or cache miss
        and Database Fallback
            alt ğŸ’¾ Cache Miss
                AM->>+DB: ğŸ“Š Query accounts table<br/>ğŸ”‘ GSI: phoneNumberIndex<br/>ğŸ” Filter: authToken match
                DB-->>-AM: ğŸ“‹ Account record with devices[]
                AM->>+CACHE: ğŸ’¾ SET account cache<br/>â° TTL: 1 hour
                CACHE-->>-AM: âœ… Account cached
            end
        end
        
        AM-->>-AF: ğŸ‘¤ AuthenticatedAccount{uuid, deviceId, capabilities}
        AF-->>-API: âœ… Authentication successful<br/>ğŸ‘¤ Principal: {account, device}
    end

    rect rgba(240, 255, 240, 0.15)
        Note over C,DB: ğŸ“± PHASE 2: Device Registration & Session Creation
        
        API->>+DM: ğŸ“± updateDeviceAttributes(account, deviceId, attributes)
        
        rect rgba(245, 255, 250, 0.3)
            Note over DM: Device State Management
            DM->>DM: ğŸ”„ Update device capabilities<br/>ğŸ“± {GCM, APNS, WebSocket support}<br/>ğŸ”” Update push tokens<br/>â° Set lastSeen timestamp
        end
        
        DM->>+SM: ğŸ« createOrUpdateSession(account, device, clientInfo)
        
        rect rgba(248, 248, 255, 0.3)
            Note over SM: Session Lifecycle
            SM->>SM: ğŸ†” Generate session ID<br/>â° Set expiration (30 days)<br/>ğŸ” Create session token<br/>ğŸ“Š Initialize session metrics
        end
        
        par Session Storage
            SM->>+CACHE: ğŸ’¾ SET session:{sessionId}<br/>ğŸ“‹ {accountId, deviceId, created, expires}<br/>â° TTL: 30 days
            CACHE-->>-SM: âœ… Session cached
        and Device Update
            DM->>+DB: ğŸ”„ UpdateItem accounts table<br/>ğŸ”‘ Key: {ACI}<br/>ğŸ“‹ Update: devices[deviceId].{lastSeen, pushTokens}
            DB-->>-DM: âœ… Device attributes updated
        end
        
        SM-->>-DM: ğŸ« SessionInfo{sessionId, token, expires}
        DM-->>-API: ğŸ“± DeviceUpdateResponse{capabilities, sessionInfo}
    end

    rect rgba(255, 248, 220, 0.15)
        Note over C,DB: ğŸ”„ PHASE 3: Ongoing Authentication & Session Validation
        
        loop ğŸ”„ Subsequent API Requests
            C->>+LB: ğŸ“¤ Any API Request<br/>ğŸ” Authorization: Bearer {sessionToken}
            LB->>+API: ğŸ”„ Route request
            API->>+AF: ğŸ” validateSession(bearerToken)
            
            AF->>+CACHE: ğŸ” GET session:{tokenHash}<br/>â° Check expiration
            
            alt âœ… Valid Session
                CACHE-->>AF: ğŸ“‹ Session data{accountId, deviceId, scope[]}
                AF->>+AM: ğŸ” getAccount(accountId)
                AM->>+CACHE: ğŸ” Account lookup (cached)
                CACHE-->>-AM: ğŸ‘¤ Account details
                AM-->>-AF: âœ… Valid account
                AF-->>API: âœ… Authenticated request<br/>ğŸ‘¤ Principal: {account, device, session}
                
                par Session Refresh
                    AF->>+CACHE: ğŸ”„ EXPIRE session:{tokenHash}<br/>â° Extend TTL by usage
                    CACHE-->>-AF: âœ… TTL extended
                and Activity Tracking
                    AF->>+CACHE: ğŸ“Š INCR activity:{accountId}:{date}<br/>â° TTL: 24 hours
                    CACHE-->>-AF: ğŸ“ˆ Activity recorded
                end
                
            else âŒ Invalid/Expired Session
                CACHE-->>AF: ğŸš« Session not found or expired
                AF-->>API: âš ï¸ HTTP 401 Unauthorized<br/>ğŸ” WWW-Authenticate: Bearer
                API-->>LB: ğŸš« Authentication required
                LB-->>C: ğŸ” Re-authentication needed
            end
            
            API->>API: ğŸ¯ Process authenticated request
            API-->>-LB: ğŸ“¤ API response
            LB-->>-C: âœ… Request completed
        end
    end

    rect rgba(255, 235, 235, 0.15)
        Note over C,DB: ğŸ”„ PHASE 4: Session Cleanup & Security
        
        Note over SM,CACHE: ğŸ§¹ Background Session Management
        
        loop â° Every 6 hours
            SM->>+CACHE: ğŸ” SCAN expired sessions<br/>ğŸ—‘ï¸ TTL < current time
            CACHE-->>-SM: ğŸ“‹ List of expired sessions
            
            SM->>+DB: ğŸ§¹ Cleanup session references<br/>ğŸ—‘ï¸ Remove from device records
            DB-->>-SM: âœ… Cleanup complete
            
            SM->>+CACHE: ğŸ“Š Collect session metrics<br/>ğŸ“ˆ Active sessions, device types
            CACHE-->>-SM: ğŸ“Š Metrics data
        end
        
        alt ğŸš¨ Security Event Detection
            SM->>SM: ğŸ” Detect suspicious activity<br/>ğŸ“± Multiple devices, geo-anomalies
            SM->>+AM: ğŸš¨ triggerSecurityReview(accountId, event)
            AM->>AM: ğŸ” Revoke suspicious sessions<br/>ğŸ“§ Send security notification
            AM-->>-SM: âœ… Security review complete
        end
    end
```

## ğŸ› ï¸ Technical Implementation Details

## Technical Notes

### Database Schema
- **Accounts Table**: Partition key: `ACI UUID`, GSI: `phoneNumber`
- **Keys Table**: Stores ACI/PNI identity keys and signed prekeys
- **Cache TTL**: 1 hour for account data, 10 minutes for verification sessions

### Security Features
- **Registration Lock**: PIN-based protection, 7-day bypass window
- **Rate Limiting**: 1 verification attempt per 5 minutes
- **Token Validation**: HMAC-SHA256 salted token verification
- **Device Expiry**: 30-day inactivity timeout

### Performance Optimizations
- **Redis Caching**: Account data cached to reduce DB queries
- **Connection Pooling**: HTTP/1.1 with keepalive to Registration Service
- **Circuit Breaker**: Fault tolerance for external service calls